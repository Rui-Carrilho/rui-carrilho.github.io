---
layout: post
title:  "What I learned building a VM in Zig (badly)"
date:   2025-01-7 23:34:21 +0000
categories: jekyll update
---

I spent the last two weeks or so building a VM, following [Justin Meiners brilliant article on it](https://www.jmeiners.com/lc3-vm/). Keep that article in hand. What started as a seemingly simple educative project ended up with me tearing my hair out while Claude, DeepSeek and ChatGPT failed to help me through an ultimately very simple sign extension problem. 

I now share with you my journey, in the hope that we can commiserate on my massive skill issue, and that you can avoid such problems if you run into them in the future.

I must however manage your expectations - despite my doing a PhD in Computer Science, my background was not in this area until recently. I (sadly) bypassed many important stuff such as PC architecture, compilers and (very sadly) data structures. I am learning all of that on my own, and if in the following stuff you see the noobness showing, well, now you know why.

All code available at [my github repo](https://github.com/Rui-Carrilho/zig-vm).

So without further ado, let's dive in.

### VMs

I will not stay long in this section. Others far more brilliant than me can explain what a [VM](https://en.wikipedia.org/wiki/Virtual_machine) is supposed to be. To put it short, you're basically simulation a whole other (weaker) PC within your PC. At this point, though the authors never mention it, it would be a good idea for you to have at least an inkling of how a computer works, and for that, you should probably know some [Assembly](https://en.wikipedia.org/wiki/Assembly_language). No need to be fluent at it, just know what sorts of OPs it performs, how they roughly work. 

You should also understand how a computer architecture works. At the end of the day, all a computer does is math, look at certain places in [memory](https://en.wikipedia.org/wiki/Computer_memory), fetch info from those bits, do math on them, place them on other bits, and so on. There are many different [architectures](https://en.wikipedia.org/wiki/Computer_architecture) (ways a PC can do these OPs in), and we're working with the [LC-3](https://en.wikipedia.org/wiki/Little_Computer_3) architecture. It's nice and simple to let us get started while still having some depth so we can see the full range of how computers work.

### Memory

Know what memory is? It's basically where the computer stores whatever data it's using/gonna be using/has used. Declaring it in Zig is easy enough:

```
const MEMORY_MAX = 1 << 16;
var memory: [MEMORY_MAX]u16 = undefined;
```

Zig's neat little `const` means that we don't have to specify the type, the compiler itself will decide the best type for `MEMORY_MAX` (in this case a `u16`, as most types in this). We then initialize an array of that size to represent our memory. Child's play!

### Registers

Here is where I decided to start being too smart for my own good. I *really* wanted to see how Zig's imports worked, so I put the registers in a different file, like so:

```
pub const Register = enum(usize) {
    R_R0 = 0,
    R_R1,
    R_R2,
    R_R3,
    R_R4,
    R_R5,
    R_R6,
    R_R7,
    R_PC, // program counter
    R_COND,
    R_COUNT,
};

pub var reg: [@intFromEnum(Register.R_COUNT)]u16 = undefined;
```

And I imported it like:

```
const registers = @import("registers.zig");
const Register = registers.Register;
const reg = registers.reg;
```

From then on I had to refer to every individual register like `Register.R_COND` or `Register.R_PC`. Too wordy. That's the price I pay for not just declaring these in `main.zig` and being done with it.

We then gotta get our instruction set going. Instruction are commands which tell CPUs what to do. Each have a code that specifies what the instruction does, and this code is called an **opcode**. Different architectures have different amounts of opcodes, and LC-3 has 16 of them. I also decided to be smart and define them in their own file like so:

```
pub const OpCode = enum(u8) {
    BR = 0x0,   // branch
    ADD = 0x1,      // add
    LD = 0x2,       // load
    ST = 0x3,       // store
    JSR = 0x4,      // jump register
    AND = 0x5,      // bitwise and
    LDR = 0x6,      // load register
    STR = 0x7,      // store register
    RTI = 0x8,      // unused
    NOT = 0x9,      // bitwise not
    LDI = 0xA,      // load indirect
    STI = 0xB,      // store indirect
    JMP = 0xC,      // jump
    RES = 0xD,      // reserved (unused)
    LEA = 0xE,      // load effective address
    TRAP = 0xF,     // execute trap
};
```

...with the same wordiness associated with calling them up. Luckily this time it's more readable.
